
## NOTE: updates to partition sizes need to be also reflected in
##  - stx-config/.../sysinv/conductor/manager.py:create_controller_filesystems()
##  - stx-config/.../sysinv/common/constants.py
##
## NOTE: When adding partitions, we currently have a max of 4 primary partitions.
##       If more than 4 partitions are required, we can use a max of 3 --asprimary,
##       to allow 1 primary logical partition with extended partitions
##
## NOTE: Max default PV size must align with the default controllerfs sizes
##
## BACKUP_OVERHEAD = 10
##
## Physical install (for disks over 240GB)
##  - DB size is doubled to allow for upgrades
##
## DEFAULT_IMAGE_STOR_SIZE = 10
## DEFAULT_DATABASE_STOR_SIZE = 20
## DEFAULT_IMG_CONVERSION_STOR_SIZE = 20
## BACKUP = DEFAULT_DATABASE_STOR_SIZE + DEFAULT_IMAGE_STOR_SIZE
##                                     + BACKUP_OVERHEAD = 40
## LOG_VOL_SIZE = 8192
## SCRATCH_VOL_SIZE = 16384
## RABBIT = 2048
## PLATFORM = 2048
## ANCHOR = 1024
## EXTENSION = 1024
## GNOCCHI = 5120
## DOCKER = 30720
## DOCKER_DIST = 16384
## ETCD = 5120
## CEPH_MON = 20480
## KUBELET_VOL_SIZE = 10240
## RESERVED_PE = 16 (based on pesize=32768)
##
## CGCS_PV_SIZE = 10240 + 2*20480 + 20480 + 40960 + 8192 + 16384 + 2048 +
##                2048 + 1024 + 1024 + 5120 + 30720 + 16384 + 5120 +
##                20480 + 10240 + 16 = 231440
##
## small install - (for disks below 240GB)
##  - DB size is doubled to allow for upgrades
##
## DEFAULT_SMALL_IMAGE_STOR_SIZE = 10
## DEFAULT_SMALL_DATABASE_STOR_SIZE = 10
## DEFAULT_SMALL_IMG_CONVERSION_STOR_SIZE = 10
## DEFAULT_SMALL_BACKUP_STOR_SIZE = 30
##
## LOG_VOL_SIZE = 8192
## SCRATCH_VOL_SIZE = 16384
## RABBIT = 2048
## PLATFORM = 2048
## ANCHOR = 1024
## EXTENSION = 1024
## GNOCCHI = 5120
## DOCKER = 30720
## DOCKER_DIST = 16384
## ETCD = 5120
## CEPH_MON = 20480
## KUBELET_VOL_SIZE = 10240
## RESERVED_PE = 16 (based on pesize=32768)
##
##
## CGCS_PV_SIZE = 10240 + 2*10240 + 10240 + 30720 + 8192 + 16384 + 2048 +
##                2048 + 1024 + 1024 + 5120 + 30720 + 16384 + 5120 +
##                20480 + 10240 + 16 = 190480
##
## NOTE: To maintain upgrade compatability within the volume group, keep the
## undersized LOG_VOL_SIZE and SCRATCH_VOL_SIZE, but size the minimally size
## physical volume correctly.
##
##  R4 AIO installations:
##  - R4 (case #1): /boot (0.5G), / (20G),
##                  cgts-vg PV (239G), /local_pv (239G)
##  - R4 (case #2): /boot (0.5G), / (20G),
##                  cgts-vg PV (239G), cgts-vg (239G)
##
##  Upgrade migration will start with R5 install and create a partition to align
##  above so filesystems within the volume group will be able to maintain their
##  sizes in R5
##    - R5 install  : /boot (0.5G), / (20G),
##                    cgts-vg PV (142G), un-partitioned (336G)
##    - R5 (case #1): /boot (0.5G), / (20G),
##                    cgts-vg PV (142G), cgts-vg PV (97G), unpartitioned (239G)
##    - R5 (case #2): /boot (0.5G), / (20G),
##                    cgts-vg PV (142G), cgts-vg PV (336G)
##

sz=$(blockdev --getsize64 $rootfs_device)
if [ $sz -le $((240*$gb)) ] ; then
    # Round CGCS_PV_SIZE to the closest upper value that can be divided by 1024.
    # 190480/1024=186.02. CGCS_PV_SIZE=187*1024=191488. Using a disk with a
    # size under 187GiB will fail.
    CGCS_PV_SIZE=191488

else
    # Round CGCS_PV_SIZE to the closest upper value that can be divided by 1024.
    # 231440/1024=226.02. CGCS_PV_SIZE=227*1024=232448.
    CGCS_PV_SIZE=232448
fi

ROOTFS_SIZE=20000
LOG_VOL_SIZE=8000
SCRATCH_VOL_SIZE=16000
PLATFORM_BACKUP_SIZE=10000
BOOT_SIZE=500
EFI_SIZE=300
ONE_MiB=$(( 1024 * 1024 ))
ONE_TENTH_MiB_IN_SECTORS=200

ROOTFS_OPTIONS="defaults"
profile_mode=`cat /proc/cmdline |xargs -n1 echo |grep security_profile= | grep extended`
if [ -n "$profile_mode" ]; then
   # Enable iversion labelling for rootfs when IMA is enabled
   ROOTFS_OPTIONS="${ROOTFS_OPTIONS},iversion"
fi

BLOCK_DEVICE=$(echo $rootfs_device |awk -F/ '{ print $3 }')

optimal_io_size=$(cat /sys/block/$BLOCK_DEVICE/queue/optimal_io_size)
logical_block_size=$(cat /sys/block/$BLOCK_DEVICE/queue/logical_block_size)
alignment_offset=$(cat /sys/block/$BLOCK_DEVICE/alignment_offset)

if [ -z ${optimal_io_size} ] || [ $optimal_io_size -le 0 ]; then
        optimal_io_size=$ONE_MiB
        wlog "Error finding optimal_io_size. Using the default ${ONE_MiB} value"
fi

if [ -z ${logical_block_size} ] || [ $logical_block_size -le 0 ]; then
        logical_block_size=512
        wlog "Error finding logical_block_size. Using the default 512 value"
fi

if [ -z ${alignment_offset} ]; then
        alignment_offset=0
        wlog "Error finding alignment_offset. Using the default 0 value"
fi

wlog "Optimal IO size: ${optimal_io_size}, logical block size: ${logical_block_size}, alignment offset: ${alignment_offset}."

START_POINT=$(( ($optimal_io_size + $alignment_offset)/$logical_block_size ))

if [ -d /sys/firmware/efi ] ; then
    BACKUP_PART=${ROOTFS_PART_PREFIX}1
    BACKUP_PART_NO=1
    START_POINT=1
    SIZE_SEC=$(( ($PLATFORM_BACKUP_SIZE * $ONE_MiB )/$logical_block_size ))
    END_POINT=$(( $START_POINT + $SIZE_SEC - 1 ))
    BACKUP_END_POINT=$END_POINT
    if [ $BACKUP_CREATED -eq 0 ] ; then
        wlog "Creating platform backup partition of ${PLATFORM_BACKUP_SIZE}MiB from ${START_POINT}s to ${END_POINT}s."
        exec_retry 5 0.5 "parted $rootfs_device mkpart primary ext4 ${START_POINT}s ${END_POINT}s"
        [ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: Partition creation failed!"
    fi

    START_POINT=$(( $END_POINT + 1 ))
    SIZE_SEC=$(( ($EFI_SIZE * $ONE_MiB )/$logical_block_size ))
    END_POINT=$(( $START_POINT + $SIZE_SEC - 1))

    wlog "Creating EFI partition of ${EFI_SIZE}MiB from ${START_POINT}s to ${END_POINT}s."
    exec_retry 5 0.5 "parted $rootfs_device mkpart primary fat32 ${START_POINT}s ${END_POINT}s"
    [ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: Partition creation failed!"

    cat<<EOF>>/tmp/part-include
part /boot/efi --fstype=efi --onpart=${ROOTFS_PART_PREFIX}2
EOF
else
    BACKUP_PART=${ROOTFS_PART_PREFIX}2
    BACKUP_PART_NO=2
    wlog "Creating 1MB BIOS GRUB partition from 1MiB to 2MiB."
    # Although we calculate proper sector between which to create the bios
    # partition, we still create it between 1MiB and 2MiB to take into account
    # upgrade scenarios.
    # If upgrading from version N to N+1, version N might have non-aligned bios
    # partition, but right after it will be the platform backup partition. If
    # the alignment is bad, then if we try to align the bios partition by
    # shifting it right, we may come over the backup partition, that is not
    # deleted by kickstarters.
    # Since the bios partition is only used for booting, it not being aligned
    # shouldn't cause any issues.
    exec_retry 5 0.5 "parted $rootfs_device mkpart primary 1MiB 2MiB"
    [ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: Partition creation failed!"

    SIZE_SEC=$(( ( $ONE_MiB )/$logical_block_size ))
    END_POINT=$(( $START_POINT + $SIZE_SEC - 1 ))

    START_POINT=$(( $END_POINT + 1 ))
    SIZE_SEC=$(( ($PLATFORM_BACKUP_SIZE * $ONE_MiB )/$logical_block_size ))
    END_POINT=$(( $START_POINT + $SIZE_SEC - 1 ))
    BACKUP_END_POINT=$END_POINT
    if [ $BACKUP_CREATED -eq 0 ] ; then
        wlog "Creating platform backup partition of ${PLATFORM_BACKUP_SIZE}MiB from ${START_POINT}s to ${END_POINT}s."
        exec_retry 5 0.5 "parted $rootfs_device mkpart primary ext4 ${START_POINT}s ${END_POINT}s"
        [ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: Partition creation failed!"
    fi
    cat<<EOF>>/tmp/part-include
part biosboot --asprimary --fstype=biosboot --onpart=${ROOTFS_PART_PREFIX}1
EOF
fi

START_POINT=$(( $END_POINT + 1 ))
SIZE_SEC=$(( ($BOOT_SIZE * $ONE_MiB )/$logical_block_size ))
END_POINT=$(( $START_POINT + $SIZE_SEC - 1 ))
wlog "Creating boot partition of ${BOOT_SIZE}MiB from ${START_POINT}s to ${END_POINT}s."
exec_retry 5 0.5 "parted $rootfs_device mkpart primary ext4 ${START_POINT}s ${END_POINT}s"
[ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: Partition creation failed!"

START_POINT=$(( $END_POINT + 1 ))
SIZE_SEC=$(( ($ROOTFS_SIZE * $ONE_MiB )/$logical_block_size ))
END_POINT=$(( $START_POINT + $SIZE_SEC - 1 ))
wlog "Creating rootfs partition of ${ROOTFS_SIZE}MiB from ${START_POINT}s to ${END_POINT}s."
exec_retry 5 0.5 "parted $rootfs_device mkpart primary ext4 ${START_POINT}s ${END_POINT}s"
[ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: Partition creation failed!"

START_POINT=$(( $END_POINT + 1 ))
SIZE_SEC=$(( ($CGCS_PV_SIZE * $ONE_MiB )/$logical_block_size ))
END_POINT=$(( $START_POINT + $SIZE_SEC - 1 ))
wlog "Creating cgcs-vg partition of ${CGCS_PV_SIZE}MiB from ${START_POINT}s to ${END_POINT}s."
exec_retry 5 0.5 "parted $rootfs_device mkpart extended ${START_POINT}s ${END_POINT}s"
[ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: Partition creation failed!"

if [ $BACKUP_CREATED -ne 0 ] ; then
    BACKUP_CURRENT_SIZE=$(parted -s $BACKUP_PART unit MiB print | grep $BACKUP_PART | awk '{print $3}' | sed 's/[^C0-9]*//g')
    if [ $BACKUP_CURRENT_SIZE -lt $PLATFORM_BACKUP_SIZE ] ; then
        wlog "Backup partition size is ${BACKUP_CURRENT_SIZE}MiB, resizing to ${PLATFORM_BACKUP_SIZE}MiB."
        # parted will throw an error about overlapping with the next partition if we don't do this
        BACKUP_END_POINT=$(( $BACKUP_END_POINT - $ONE_TENTH_MiB_IN_SECTORS ))
        exec_retry 5 0.5 "parted $rootfs_device resizepart $BACKUP_PART_NO ${BACKUP_END_POINT}s"
        [ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: resize of platform backup partition failed!"
        exec_retry 2 0.1 "e2fsck -p -f $BACKUP_PART"
        [ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: e2fsck failed on platform backup partition!"
        exec_retry 2 1 "resize2fs $BACKUP_PART"
        [ $? -ne 0 ] && report_pre_failure_with_msg "ERROR: Filed to resize ext4 fs of platform backup partition!"
    elif [ $BACKUP_CURRENT_SIZE -gt $PLATFORM_BACKUP_SIZE ] ; then
        report_pre_failure_with_msg "ERROR: Backup partition is ${BACKUP_CURRENT_SIZE}MiB expected size is less or equal to ${PLATFORM_BACKUP_SIZE}MiB."
    else
        wlog "Backup partition size is correct: ${PLATFORM_BACKUP_SIZE}MiB."
    fi

    cat<<EOF>>/tmp/part-include
part /opt/platform-backup --fstype=ext4 --asprimary --noformat --onpart=$BACKUP_PART --fsoptions="$ROOTFS_OPTIONS"
EOF
else
    cat<<EOF>/tmp/backup-guid-change.sh
echo "\$(date '+%Y-%m-%d %H:%M:%S.%3N') - Updating backup partition GUID."
flock $rootfs_device sgdisk --change-name=${BACKUP_PART_NO}:"${BACKUP_PART_LABEL}" --typecode=${BACKUP_PART_NO}:"${BACKUP_PART_GUID}" $rootfs_device || exit 1
EOF

    cat<<EOF>>/tmp/part-include
part /opt/platform-backup --fstype=ext4 --asprimary --onpart=$BACKUP_PART --fsoptions="$ROOTFS_OPTIONS"
EOF
fi

cat<<EOF>>/tmp/part-include
part /boot --fstype=ext4 --asprimary --onpart=${ROOTFS_PART_PREFIX}3 --fsoptions="$ROOTFS_OPTIONS"
part pv.253004 --onpart=${ROOTFS_PART_PREFIX}5
volgroup cgts-vg --pesize=32768 pv.253004
logvol /var/log --fstype=ext4 --vgname=cgts-vg --size=$LOG_VOL_SIZE --name=log-lv
logvol /scratch --fstype=ext4 --vgname=cgts-vg --size=$SCRATCH_VOL_SIZE --name=scratch-lv
part / --fstype=ext4 --asprimary --onpart=${ROOTFS_PART_PREFIX}4 --fsoptions="$ROOTFS_OPTIONS"
EOF

