%pre --erroronfail

# Source common functions
. /tmp/ks-functions.sh

# This is a really fancy way of finding the first usable disk for the
# install and not stomping on the USB device if it comes up first

# First, parse /proc/cmdline to find the boot args
set -- `cat /proc/cmdline`
for I in $*; do case "$I" in *=*) eval $I 2>/dev/null;; esac; done

if [ -z "$boot_device" ]; then
    boot_device=$(get_disk_dev)
fi
if [ -z "$rootfs_device" ]; then
    rootfs_device=$(get_disk_dev)
fi

# Convert to by-path
orig_rootfs_device=$rootfs_device
rootfs_device=$(get_by_path $rootfs_device)

orig_boot_device=$boot_device
boot_device=$(get_by_path $boot_device)

if [ ! -e "$rootfs_device" -o ! -e "$boot_device" ] ; then
    # Touch this file to prevent Anaconda from dying an ungraceful death
    touch /tmp/part-include

    report_pre_failure_with_msg "ERROR: Specified installation ($orig_rootfs_device) or boot ($orig_boot_device) device is invalid."
fi

# Ensure specified device is not a USB drive
udevadm info --query=property --name=$rootfs_device |grep -q '^ID_BUS=usb' || \
    udevadm info --query=property --name=$boot_device |grep -q '^ID_BUS=usb'
if [ $? -eq 0 ]; then
    # Touch this file to prevent Anaconda from dying an ungraceful death
    touch /tmp/part-include

    report_pre_failure_with_msg "ERROR: Specified installation ($orig_rootfs_device) or boot ($orig_boot_device) device is a USB drive."
fi

# Deactivate existing volume groups to avoid Anaconda issues with pre-existing groups
vgs --noheadings -o vg_name | xargs --no-run-if-empty -n 1 vgchange -an

# Remove the volume groups that have physical volumes on the root disk
for vg in $(vgs --noheadings -o vg_name); do
    pvs --select "vg_name=$vg" --noheadings -o pv_name | grep -q "$(get_disk $rootfs_device)"
    if [ $? -ne 0 ]; then
        continue
    fi
    echo "Removing vg $vg"
    lvremove --force $vg
    pvs --select "vg_name=$vg" --noheadings -o pv_name | xargs --no-run-if-empty pvremove --force --force --yes
    vgs --select "vg_name=$vg" --noheadings -o vg_name | xargs --no-run-if-empty vgremove --force
done

ONLYUSE_HDD=""
part_type_guid_str="Partition GUID code"
if [ "$(curl -sf http://pxecontroller:6385/v1/upgrade/$(hostname)/in_upgrade 2>/dev/null)" = "true" ]; then
    # In an upgrade, only wipe the disk with the rootfs and boot partition
    echo "In upgrade, wiping only $rootfs_device"
    WIPE_HDD="$(get_disk $rootfs_device)"
    ONLYUSE_HDD="$(basename $(get_disk $rootfs_device))"
    if [ "$(get_disk $rootfs_device)" != "$(get_disk $boot_device)" ]; then
        WIPE_HDD="$WIPE_HDD,$(get_disk $boot_device)"
        ONLYUSE_HDD="$ONLYUSE_HDD,$(basename $(get_disk $boot_device))"
    fi
else
    # Make a list of all the hard drives that are to be wiped
    WIPE_HDD=""
    # Partition type OSD has a unique globally identifier
    CEPH_OSD_GUID="4FBD7E29-9D25-41B8-AFD0-062C0CEFF05D"

    # Check if we wipe OSDs
    if [ "$(curl -sf http://pxecontroller:6385/v1/ihosts/wipe_osds 2>/dev/null)" = "true" ]; then
        echo "Wipe OSD data."
        WIPE_CEPH_OSDS="true"
    else
        echo "Skip Ceph OSD data wipe."
        WIPE_CEPH_OSDS="false"
    fi

    for f in /dev/disk/by-path/*
    do
        dev=$(readlink -f $f)
        lsblk --nodeps --pairs $dev | grep -q 'TYPE="disk"'
        if [ $? -ne 0 ]
        then
            continue
        fi

        # Avoid wiping USB drives
        udevadm info --query=property --name=$dev |grep -q '^ID_BUS=usb' && continue

        # Avoid wiping ceph osds if sysinv tells us so
        if [ ${WIPE_CEPH_OSDS} == "false" ]; then
            wipe_dev="true"
            part_numbers=( `parted -s $dev print | awk '$1 == "Number" {i=1; next}; i {print $1}'` )
            # Scanning the partitions looking for CEPH OSDs and
            # skipping any disk found with such partitions
            for part_number in "${part_numbers[@]}"; do
                sgdisk_part_info=$(flock $dev sgdisk -i $part_number $dev)
                part_type_guid=$(echo "$sgdisk_part_info" | grep "$part_type_guid_str" | awk '{print $4;}')
                if [ "$part_type_guid" == $CEPH_OSD_GUID ]; then
                    echo "OSD found on $dev, skipping wipe"
                    wipe_dev="false"
                    break
                fi
            done
            if [ "$wipe_dev" == "false" ]; then
                continue
            fi
        fi

        # Add device to the wipe list
        devname=$(basename $dev)
        if [ -e $dev -a "$ISO_DEV" != "../../$devname" -a "$USB_DEV" != "../../$devname" ]; then
            if [ -n "$WIPE_HDD" ]; then
                WIPE_HDD=$WIPE_HDD,$dev
            else
                WIPE_HDD=$dev
            fi
        fi
    done
    echo "Not in upgrade, wiping disks: $WIPE_HDD"
fi


ROOTFS_DISK=$(get_disk $rootfs_device)
ROOTFS_PART_PREFIX=$ROOTFS_DISK
#check if disk is nvme
case $ROOTFS_DISK in
    *"nvme"*)
        ROOTFS_PART_PREFIX=${ROOTFS_PART_PREFIX}p
    ;;
esac

BACKUP_CREATED=0

# Note that the BA5EBA11-0000-1111-2222- is the prefix used by STX and it's defined in sysinv constants.py.
# Since the 000000000001 suffix is used by custom stx LVM partitions,
# the next suffix is used for the persistent backup partition (000000000002)
BACKUP_PART_LABEL="Platform Backup"
BACKUP_PART_GUID="BA5EBA11-0000-1111-2222-000000000002"

for dev in ${WIPE_HDD//,/ }
do
    # Clearing previous GPT tables or LVM data
    # Delete the first few bytes at the start and end of the partition. This is required with
    # GPT partitions, they save partition info at the start and the end of the block.
    # Do this for each partition on the disk, as well.
    part_numbers=( $(parted -s $dev print | awk '$1 == "Number" {i=1; next}; i {print $1}') )
    for part_number in "${part_numbers[@]}"; do
        part=$dev$part_number
        case $part in
            *"nvme"*)
                part=${dev}p${part_number}
            ;;
        esac
        if [ "$dev" == "$ROOTFS_DISK" ]; then
            sgdisk_part_info=$(flock $dev sgdisk -i $part_number $dev)
            part_type_guid=$(echo "$sgdisk_part_info" | grep "$part_type_guid_str" | awk '{print $4;}')
            part_fstype=$(blkid -s TYPE -o value $part)
            if [ "$part_type_guid" == $BACKUP_PART_GUID -a "${part_fstype}" == "ext4" ]; then
                echo "Skipping wipe backup partition $part"
                BACKUP_CREATED=1
                continue
           fi
        fi
        echo "Wiping partition $part"
        dd if=/dev/zero of=$part bs=512 count=34
        dd if=/dev/zero of=$part bs=512 count=34 seek=$((`blockdev --getsz $part` - 34))
        parted -s $dev rm $part_number
        # LP 1876374: On some nvme systems udev doesn't correctly remove the
        # links to the deleted partitions from /dev/nvme* causing them to be
        # seen as non block devices.
        sleep 0.3 # Wait for udev to settle
        rm -f $part # Delete remaining /dev node leftover
    done
    if [ $BACKUP_CREATED -eq 0 -o "$dev" != "$ROOTFS_DISK" ]; then
        echo "Creating disk label for $dev"
        parted -s $dev mktable gpt
    fi

done

# Check for remaining cgts-vg PVs, which could potentially happen
# in an upgrade where we're not wiping all disks.
# If we ever create other volume groups from kickstart in the future,
# include them in this search as well.
partitions=$(pvs --select 'vg_name=cgts-vg' -o pv_name --noheading | grep -v '\[unknown\]')
for p in $partitions
do
    echo "Pre-wiping $p from kickstart (cgts-vg present)"
    dd if=/dev/zero of=$p bs=512 count=34
    dd if=/dev/zero of=$p bs=512 count=34 seek=$((`blockdev --getsz $p` - 34))
done

let -i gb=1024*1024*1024

if [ -n "$ONLYUSE_HDD" ]; then
    cat<<EOF>>/tmp/part-include
ignoredisk --only-use=$ONLYUSE_HDD
EOF
fi
